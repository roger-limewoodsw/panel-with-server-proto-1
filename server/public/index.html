<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avid Panel Plugin</title>
    <link rel="stylesheet" href="styles.css">
    
    <!-- Setup Node.js compatibility before loading google-protobuf -->
    <script>
        // Ensure exports and module are available before loading google-protobuf
        if (typeof exports === 'undefined') {
            window.exports = {};
        }
        if (typeof module === 'undefined') {
            window.module = { exports: window.exports };
        }
        
        // Add comprehensive Google Closure Library polyfills for google-protobuf
        if (typeof window.goog === 'undefined') {
            window.goog = {};
        }
        
        // Add goog.asserts with all needed methods
        if (typeof window.goog.asserts === 'undefined') {
            window.goog.asserts = {
                assert: function(condition, message) {
                    if (!condition) {
                        throw new Error(message || 'Assertion failed');
                    }
                    return condition;
                },
                fail: function(message) {
                    throw new Error(message || 'Assertion failed');
                }
            };
        }
        
        // Add goog.crypt.base64 for protobuf
        if (typeof window.goog.crypt === 'undefined') {
            window.goog.crypt = {};
        }
        if (typeof window.goog.crypt.base64 === 'undefined') {
            window.goog.crypt.base64 = {
                encodeByteArray: function(bytes, opt_webSafe) {
                    // Simple base64 encoding for protobuf
                    let result = '';
                    let i;
                    for (i = 2; i < bytes.length; i += 3) {
                        result += btoa(String.fromCharCode.apply(null, bytes.subarray(i-2, i+1)));
                    }
                    if (i === bytes.length + 1) {
                        result += btoa(String.fromCharCode.apply(null, bytes.subarray(i-2, i-1))) + '=';
                    } else if (i === bytes.length) {
                        result += btoa(String.fromCharCode.apply(null, bytes.subarray(i-2, i))) + '==';
                    }
                    return result;
                }
            };
        }
    </script>
    
    <!-- Load browser-compatible google-protobuf library -->
    <script src="google-protobuf-browser.js"></script>
    
    <!-- Setup essential compatibility for gRPC files -->
    <script>
        // Make jspb globally available after google-protobuf loads
        window.jspb = jspb;
        
        // gRPC files need these specific goog functions - add minimal implementations
        if (typeof window.goog === 'undefined') {
            window.goog = jspb; // Use jspb as goog base
        }
        
        // Essential goog functions needed by gRPC files
        jspb.exportSymbol = function(name, object, opt_objectToExportTo) {
            var parts = name.split('.');
            var cur = opt_objectToExportTo || window;
            for (var part; parts.length && (part = parts.shift());) {
                if (parts.length) {
                    cur[part] = cur[part] || {};
                    cur = cur[part];
                } else {
                    cur[part] = object;
                }
            }
        };
        
        // Add to both jspb and goog for compatibility
        window.goog.exportSymbol = jspb.exportSymbol;
        
        // Object extend function needed by gRPC files
        jspb.object = jspb.object || {};
        jspb.object.extend = function(target, source) {
            for (var key in source) {
                if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                }
            }
            return target;
        };
        window.goog.object = jspb.object;
        
        // Add inherits function needed by protobuf files
        jspb.inherits = function(childCtor, parentCtor) {
            function tempCtor() {}
            tempCtor.prototype = parentCtor.prototype;
            childCtor.superClass_ = parentCtor.prototype;
            childCtor.prototype = new tempCtor();
            childCtor.prototype.constructor = childCtor;
            
            childCtor.base = function(me, methodName, var_args) {
                var args = Array.prototype.slice.call(arguments, 2);
                return parentCtor.prototype[methodName].apply(me, args);
            };
        };
        window.goog.inherits = jspb.inherits;
        
        // Mock require function for the gRPC files
        window.require = function(module) {
            if (module === 'google-protobuf') {
                return jspb;
            }
            if (module === 'grpc-web') {
                return window.grpc.web;
            }
            if (module.includes('MCAPI_Types_pb.js')) {
                return window.proto.mcapi || {};
            }
            if (module.includes('MCAPI_pb.js')) {
                return window.proto.mcapi || {};
            }
            if (module.includes('descriptor_pb.js')) {
                return {
                    MethodOptions: {
                        extensionsBinary: {},
                        extensions: {}
                    },
                    FileOptions: {
                        extensionsBinary: {},
                        extensions: {}
                    }
                };
            }
            return {};
        };
        
        // Global compatibility
        if (typeof global === 'undefined') {
            window.global = window;
        }
        
        // Add grpc-web specific objects - make sure this is available before gRPC files load
        window.grpc = window.grpc || {};
        window.grpc.web = window.grpc.web || {};
        
        // Define MethodType enum
        window.grpc.web.MethodType = {
            UNARY: 'unary',
            SERVER_STREAMING: 'server_streaming',
            CLIENT_STREAMING: 'client_streaming', 
            BIDI_STREAMING: 'bidi_streaming'
        };
        
        // Define MethodDescriptor constructor
        window.grpc.web.MethodDescriptor = function(path, methodType, requestType, responseType, requestSerializeFn, responseDeserializeFn) {
            this.path = path;
            this.methodType = methodType;
            this.requestType = requestType;
            this.responseType = responseType;
            this.requestSerializeFn = requestSerializeFn;
            this.responseDeserializeFn = responseDeserializeFn;
        };
        
        // Define client base classes only if they don't already exist (development mode)
        // In Media Composer, these should already be provided by the Panel SDK
        if (typeof window.mcapi === 'undefined') {
            // Development mode - provide mocks
            console.log('üîß Setting up development mode gRPC mocks');
            window.grpc.web.AbstractClientBase = function() {};
            window.grpc.web.GrpcWebClientBase = function(opt_options, opt_client) {
                this.hostname_ = '';
                this.credentials_ = null;
                this.options_ = opt_options || {};
                
                this.rpcCall = function(method, request, metadata, methodDescriptor, callback) {
                    console.warn('üîÑ gRPC call attempted in development mode:', method);
                    setTimeout(() => {
                        if (callback) {
                            callback(new Error('Not connected to Media Composer (development mode)'), null);
                        }
                    }, 100);
                };
                
                this.unaryCall = this.rpcCall;
            };
        } else {
            // Media Composer mode - let the real gRPC client handle protocol details
            console.log('üé¨ Media Composer detected - using native gRPC client');
            console.log('üîç Available grpc.web:', window.grpc.web);
            console.log('üì¶ grpc.web keys:', window.grpc.web ? Object.keys(window.grpc.web) : 'none');
            
            // Debug the mcapi object to understand Media Composer's gRPC interface
            console.log('üîç Exploring mcapi object structure...');
            if (typeof mcapi !== 'undefined') {
                console.log('üìã mcapi keys:', Object.getOwnPropertyNames(mcapi));
                console.log('üìã mcapi methods:', Object.getOwnPropertyNames(mcapi).filter(key => typeof mcapi[key] === 'function'));
                
                // Check for any gRPC-related methods
                const grpcMethods = Object.getOwnPropertyNames(mcapi).filter(key => 
                    key.toLowerCase().includes('grpc') || 
                    key.toLowerCase().includes('call') || 
                    key.toLowerCase().includes('service') ||
                    key.toLowerCase().includes('request')
                );
                console.log('üéØ Potential gRPC methods:', grpcMethods);
            }
            
            // The generated MCAPIClient needs GrpcWebClientBase but Media Composer doesn't provide it
            // We need to provide a bridge that uses Media Composer's native gRPC capabilities
            if (!window.grpc.web.GrpcWebClientBase) {
                console.log('üîß Providing GrpcWebClientBase bridge for Media Composer integration');
                
                window.grpc.web.GrpcWebClientBase = function(hostname, credentials, options) {
                    console.log('üèóÔ∏è GrpcWebClientBase created for:', hostname);
                    this.hostname_ = hostname;
                    this.credentials_ = credentials;
                    this.options_ = options || {};
                };
                
                // Add the rpcCall method that the generated client expects
                window.grpc.web.GrpcWebClientBase.prototype.rpcCall = function(method, request, metadata, methodDescriptor, callback) {
                    console.log('üé¨ Making gRPC-web HTTP request:', method);
                    console.log('üì¶ Request size:', request.serializeBinary().length, 'bytes');
                    console.log('üîë Metadata:', metadata);
                    
                    // Media Composer provides gateway address, so we make HTTP requests directly
                    try {
                        const requestBytes = request.serializeBinary();
                        
                        // Prepare headers for gRPC-Web
                        const headers = {
                            'Content-Type': 'application/grpc-web+proto',
                            'X-Grpc-Web': '1'
                        };
                        
                        // Add metadata (like access token) to headers
                        if (metadata) {
                            Object.keys(metadata).forEach(key => {
                                headers[key.toLowerCase()] = metadata[key];
                            });
                        }
                        
                        console.log('üîë Request headers:', headers);
                        console.log('üåê Making fetch to:', method);
                        
                        // Make the HTTP request to Media Composer's gRPC gateway
                        fetch(method, {
                            method: 'POST',
                            headers: headers,
                            body: requestBytes,
                            mode: 'cors',
                            credentials: 'include'
                        })
                        .then(response => {
                            console.log('üì° Response received:', response.status, response.statusText);
                            console.log('üìã Response headers:');
                            for (let [key, value] of response.headers.entries()) {
                                console.log(`   ${key}: ${value}`);
                            }
                            
                            if (!response.ok) {
                                // Check for gRPC errors in headers
                                const grpcStatus = response.headers.get('grpc-status');
                                const grpcMessage = response.headers.get('grpc-message');
                                if (grpcStatus && grpcStatus !== '0') {
                                    throw new Error(`gRPC Error ${grpcStatus}: ${grpcMessage || 'Unknown error'}`);
                                }
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            return response.arrayBuffer();
                        })
                        .then(responseBytes => {
                            console.log('üì¶ Response received, size:', responseBytes.byteLength, 'bytes');
                            
                            // Handle empty response
                            if (responseBytes.byteLength === 0) {
                                console.log('üì≠ Empty response - creating default response object');
                                try {
                                    const emptyResponse = new methodDescriptor.responseType();
                                    console.log('‚úÖ Empty response object created successfully');
                                    callback(null, emptyResponse);
                                    return;
                                } catch (emptyError) {
                                    console.error('‚ùå Failed to create empty response:', emptyError);
                                    callback(new Error('Received empty response from Media Composer'), null);
                                    return;
                                }
                            }
                            
                            try {
                                // For very small responses, try raw deserialization first
                                if (responseBytes.byteLength < 5) {
                                    console.log('‚ö†Ô∏è Response too small for gRPC-Web header, treating as raw message');
                                    const messageBytes = new Uint8Array(responseBytes);
                                    const responseMessage = methodDescriptor.responseType.deserializeBinary(messageBytes);
                                    console.log('‚úÖ Raw response deserialized successfully');
                                    callback(null, responseMessage);
                                    return;
                                }
                                
                                // gRPC-Web responses have a 5-byte header: 1 byte compression + 4 bytes length
                                const dataView = new DataView(responseBytes);
                                const compressionFlag = dataView.getUint8(0);
                                const messageLength = dataView.getUint32(1, false); // big-endian
                                
                                console.log('üîç gRPC-Web header - compression:', compressionFlag, 'length:', messageLength);
                                
                                if (messageLength > responseBytes.byteLength - 5) {
                                    console.warn('‚ö†Ô∏è Message length mismatch, trying raw deserialization');
                                    const messageBytes = new Uint8Array(responseBytes);
                                    const responseMessage = methodDescriptor.responseType.deserializeBinary(messageBytes);
                                    console.log('‚úÖ Raw response deserialized successfully');
                                    callback(null, responseMessage);
                                    return;
                                }
                                
                                const messageBytes = new Uint8Array(responseBytes, 5, messageLength);
                                console.log('üì¶ Message extracted, size:', messageBytes.length, 'bytes');
                                
                                // Deserialize using the response type from the method descriptor
                                const responseMessage = methodDescriptor.responseType.deserializeBinary(messageBytes);
                                console.log('‚úÖ Response deserialized successfully');
                                
                                callback(null, responseMessage);
                            } catch (deserError) {
                                console.error('‚ùå Failed to deserialize response:', deserError);
                                console.log('üîç Raw response bytes:', new Uint8Array(responseBytes));
                                callback(deserError, null);
                            }
                        })
                        .catch(networkError => {
                            console.error('‚ùå Network/HTTP error:', networkError);
                            callback(networkError, null);
                        });
                        
                    } catch (error) {
                        console.error('‚ùå Request preparation failed:', error);
                        setTimeout(() => callback(error, null), 10);
                    }
                };
                
                // Add serverStreaming method for getBins
                window.grpc.web.GrpcWebClientBase.prototype.serverStreaming = function(method, request, metadata, methodDescriptor) {
                    console.log('üåä Native streaming gRPC call via Media Composer:', method);
                    
                    // Create a mock stream object
                    const stream = {
                        on: function(event, callback) {
                            console.log('üì° Stream event listener added:', event);
                            if (event === 'error') {
                                // For now, emit an error since we need to figure out streaming
                                setTimeout(() => {
                                    callback(new Error('Streaming not yet implemented for Media Composer native transport'));
                                }, 100);
                            }
                        }
                    };
                    
                    return stream;
                };
                
                console.log('‚úÖ GrpcWebClientBase bridge installed');
            } else {
                console.log('‚úÖ GrpcWebClientBase already available');
            }
        }
        
        // Initialize proto namespace
        window.proto = window.proto || {};
        window.proto.mcapi = window.proto.mcapi || {};
    </script>
    
    <!-- Load gRPC-web dependencies in STRICT ORDER -->
    <script src="/grpc-web/MCAPI_Types_pb.js"></script>
    <script src="/grpc-web/MCAPI_pb.js"></script>
    <script src="/grpc-web/MCAPI_grpc_web_pb.js"></script>
    
    <!-- Enhanced gRPC loading debug -->
    <script>
        console.log('=== gRPC Loading Debug ===');
        
        // Debug gRPC loading immediately
        console.log('typeof proto:', typeof proto);
        console.log('typeof mcapi:', typeof mcapi);
        
        if (typeof proto !== 'undefined') {
            console.log('proto keys:', Object.keys(proto));
            console.log('proto.mcapi available:', !!proto.mcapi);
            
            if (proto.mcapi) {
                console.log('proto.mcapi keys:', Object.keys(proto.mcapi));
                console.log('üì¶ Available clients:', 
                    proto.mcapi.MCAPIClient ? 'MCAPIClient' : 'none', 
                    proto.mcapi.MCAPIPromiseClient ? 'MCAPIPromiseClient' : 'none'
                );
                
                // Test constructor availability
                console.log('GetAppInfoRequest available:', typeof proto.mcapi.GetAppInfoRequest);
                console.log('GetAppInfoRequestBody available:', typeof proto.mcapi.GetAppInfoRequestBody);
            }
        }
        
        console.log('‚úÖ gRPC loading debug complete');
    </script>
</head>
<body>
    <div id="app">
        <header>
            <h1>Avid Panel SDK Plugin</h1>
            <div id="connection-status" class="status-badge">Initializing...</div>
        </header>
        
        <main>
            <!-- Connection Info -->
            <section class="info-panel">
                <h2>Connection Information</h2>
                <div id="connection-info">
                    <p>Waiting for Media Composer...</p>
                </div>
            </section>
            
            <!-- Project Info -->
            <section class="info-panel">
                <h2>Project Information</h2>
                <div id="project-info">
                    <p>No project loaded</p>
                </div>
            </section>
            
            <!-- Bin Contents -->
            <section class="info-panel">
                <h2>Current Bin</h2>
                <div id="bin-contents">
                    <p>Select a bin in Media Composer</p>
                </div>
            </section>
            
            <!-- Event Log -->
            <section class="info-panel">
                <h2>Event Log</h2>
                <div id="event-log"></div>
            </section>
            
            <!-- Actions -->
            <section class="actions-panel">
                <h2>Actions</h2>
                <button id="refresh-btn">Refresh Project Info</button>
                <button id="get-bins-btn">Get All Bins</button>
                <button id="clear-log-btn">Clear Event Log</button>
            </section>
        </main>
    </div>
    
    <script src="app.js"></script>
</body>
</html>